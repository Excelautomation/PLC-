Package dk.aau.sw402F15.parser;

Helpers
ht  = 0x0009;
lf  = 0x000a;
ff  = 0x000c;
cr  = 0x000d;
sp  = ' ';

line_terminator = lf | cr | cr lf;

all = [0 .. 255];

digit =	['0' .. '9'];
letter = ['a' .. 'z'] | ['A' .. 'Z'];
specials = '_';

letter_or_digit = (letter | digit);
letter_or_specials = (letter | specials);
letter_or_digit_or_specials = (letter_or_digit | specials);

not_line_terminator = [all - [cr + lf]];

Tokens
comments = ('//' not_line_terminator* line_terminator);

l_par = '(';
r_par = ')';
l_brc = '{';
r_brc = '}';
l_bkt = '[';
r_bkt = ']';

semi = ';';
colon = ':';
comma = ',';
dot = '.';

// Operators
add_assignment_operator = '+=';
sub_assignment_operator = '-=';
mult_assignment_operator = '*=';
div_assignment_operator = '/=';
mod_assignment_operator = '%=';
assignment_operator = '=';

increment_operator = '++';
decrement_operator = '--';

equal_operator = '==';
not_equal_operator = '!=';
and_operator = '&&';
or_operator = '||';

ternary_operator = '?';

add_operator = '+';
sub_operator = '-';
mult_operator = '*';
div_operator = '/';
mod_operator = '%';
negate_operator = '!';

greater_than_operator = '>';
less_than_operator = '<';
greater_than_or_equal_operator = '>=';
less_than_or_equal_operator = '<=';

// Keywords
char_keyword        = 'char';
bool_keyword        = 'bool';
int_keyword         = 'int';
long_keyword        = 'long';
double_keyword      = 'double';
float_keyword       = 'float';
default_keyword     = 'default';
switch_keyword      = 'switch';
case_keyword        = 'case';
break_keyword       = 'break';
continue_keyword    = 'continue';
const_keyword       = 'const';
enum_keyword        = 'enum';
port_keyword        = 'port';
timer_keyword       = 'timer';
void_keyword        = 'void';
return_keyword      = 'return';
struct_keyword      = 'struct';

if_keyword = 'if';
else_keyword = 'else';

for_keyword = 'for';
while_keyword = 'while';

true_keyword = 'true';
false_keyword = 'false';

// Literal
integer_literal = (digit)+;
decimal_literal = (digit)+ '.' (digit)+;

// Identifier
port_input_identifier = 'I#';
port_output_identifier = 'O#';
port_memory_identifier = 'M#';
port_analog_input_identifier = 'AI#';
port_analog_output_identifier = 'AO#';
identifier = letter_or_specials letter_or_digit_or_specials*;

// White space
white_space = (sp | ht | ff | line_terminator)+;

Ignored Tokens
	comments,
	white_space;

Productions

program {-> program} =
	root_declaration*																									{-> New program([root_declaration])}
;

// Scope
scope {-> statement} = 
    l_brc statement* r_brc																								{-> New statement.scope([statement.statement])}
;

// Types
type_specifier {-> type_specifier} = 
    {char} char_keyword																									{-> New type_specifier.char()}
  | {bool} bool_keyword																									{-> New type_specifier.bool()}
  | {int} int_keyword																									{-> New type_specifier.int()}
  | {long} long_keyword																									{-> New type_specifier.long()}
  | {float} float_keyword																								{-> New type_specifier.float()}
  | {double} double_keyword																								{-> New type_specifier.double()}
  | {timer} timer_keyword																								{-> New type_specifier.timer()}
  | {port} port_keyword																									{-> New type_specifier.port()}
  | {enum} enum_keyword identifier                                                                                      {-> New type_specifier.identifier(identifier)}
  | {identifier} struct_keyword identifier																				{-> New type_specifier.identifier(identifier)}
;

// Declaration in root scope
root_declaration {-> root_declaration} =
	{variable} declaration																								{-> New root_declaration.declaration(declaration.declaration)}
  |	{function} function_definition																						{-> function_definition.root_declaration}
  | {struct} struct_definition																							{-> struct_definition.root_declaration}
  | {enum} enum_definition                                                                                              {-> enum_definition.root_declaration}
;

// Function definition
function_definition {-> root_declaration} =
	{function} type_specifier identifier l_par formal_parameter? r_par l_brc statement* r_brc							{-> New root_declaration.function(type_specifier, identifier, [formal_parameter.declaration], [statement])}
  | {method} void_keyword identifier l_par formal_parameter? r_par l_brc statement* r_brc								{-> New root_declaration.function(New type_specifier.void(), identifier, [formal_parameter.declaration], [statement])}
;

// Formal parameters
formal_parameter {-> declaration*} =
  {single} type_qualifier? type_specifier identifier array_definition?													{-> [New declaration(type_specifier, identifier, type_qualifier.type_qualifier, array_definition.array_definition)]}
  | {multiple} type_qualifier? type_specifier identifier array_definition? comma formal_parameter						{-> [New declaration(type_specifier, identifier, type_qualifier.type_qualifier, array_definition.array_definition), formal_parameter.declaration]}
;

// Struct
struct_definition {-> root_declaration} =
	struct_keyword identifier l_brc program r_brc																		{-> New root_declaration.struct(identifier, program)}
;

// Enum
enum_definition {-> root_declaration} =
	enum_keyword identifier l_brc enum_flags r_brc																		{-> New root_declaration.enum(identifier, [enum_flags.enum_flag])}
;

enum_flags {-> enum_flag*} =
    {single} enum_flag                                                                                                  {-> [enum_flag.enum_flag]}
  | {multiple} enum_flag comma enum_flags                                                                               {-> [enum_flag.enum_flag, enum_flags.enum_flag]}
;

enum_flag {-> enum_flag} =
    {simple} identifier                                                                                                 {-> New enum_flag(identifier, Null)}
  | {value} identifier assignment_operator integer_literal                                                              {-> New enum_flag(identifier, integer_literal)}
;

// Type-qualifier
type_qualifier {-> type_qualifier} =
    {const} const_keyword                                                                                               {-> New type_qualifier.const()}
;

// Declaration
declaration {-> declaration} =
	{simple} type_qualifier? type_specifier identifier array_definition? semi											{-> New declaration(type_specifier.type_specifier, identifier, type_qualifier.type_qualifier, array_definition.array_definition)}
  | {assignment} type_qualifier? type_specifier identifier array_definition? assignment_operator expr semi				{-> New declaration.assignment(type_specifier.type_specifier, identifier, type_qualifier.type_qualifier, array_definition.array_definition, expr)}
;

array_definition {-> array_definition} =
    l_bkt [number]:integer_literal? r_bkt                                                                                {-> New array_definition(number)}
;

// Statements
statement {-> statement} =
	{declaration} declaration																							{-> New statement.declaration(declaration.declaration)}
  |	{expr} expr	semi																									{-> New statement.expr(expr.expr)}
  
  // Conditional
  | {if} if_statement																									{-> if_statement.statement}
  
  // Iteration
  | {while} while_keyword l_par [condition]:expr r_par scope															{-> New statement.while(condition.expr, [scope.statement])}
  | {for} for_keyword l_par [initilizer]:expr? [s1]:semi [condition]:expr? [s2]:semi [iterator]:expr? r_par scope		{-> New statement.for(initilizer.expr, condition.expr, iterator.expr)} // TODO: for with declaration
  
  // Control
  | {return} return_keyword semi																						{-> New statement.return()}
  | {return_expr} return_keyword expr semi																				{-> New statement.return_expr(expr.expr)}
  | {continue} continue_keyword semi                                                                                    {-> New statement.continue()}
  | {break} break_keyword semi                                                                                          {-> New statement.break()}
;

// If
if_statement {-> statement} =
    {if} if_keyword l_par [condition]:expr r_par scope																	{-> New statement.if(condition.expr, [scope.statement])}
  | {if_else} if_keyword l_par [condition]:expr r_par scope else_statement												{-> New statement.if_else(condition.expr, [scope.statement], [else_statement.statement])}
;

else_statement {-> statement} = 
    {else} else_keyword scope																							{-> scope.statement}
  | {else_if} else_keyword if_statement																					{-> if_statement.statement}
;

// Switch
switch_statement {-> statement} =
    {switch} switch_keyword l_par [condition]:expr r_par scope                                                          {-> New statement.switch(condition.expr, [scope.statement])}
;

label_statements {-> statement} =
    {case} case_keyword [condition]:expr semi scope                                                                     {-> New statement.case(condition.expr, [scope.statement])}
  | {default} default_keyword semi scope                                                                                {-> New statement.default([scope.statement])}
;

// Expression
// C operator precedence - precedence inverted
// Precedence 14
expr {-> expr} =
	// Assignment
	{assignment} identifier assignment_operator expr																	{-> New expr.assignment(identifier, expr.expr)}
	
	// Compound
  |	{compound_add} identifier add_assignment_operator expr																{-> New expr.compound_add(identifier, expr.expr)}
  | {compound_sub} identifier sub_assignment_operator expr																{-> New expr.compound_sub(identifier, expr.expr)}
  | {compound_mult} identifier mult_assignment_operator expr															{-> New expr.compound_mult(identifier, expr.expr)}
  | {compound_div} identifier div_assignment_operator expr																{-> New expr.compound_div(identifier, expr.expr)}
  | {compound_mod} identifier mod_assignment_operator expr																{-> New expr.compound_mod(identifier, expr.expr)}
  | {factor} [expr]:expr13																								{-> expr.expr}
;

// Precedence 13 (Ternary conditional)
expr13 {-> expr} =
    {ternary} [condition]:expr13 ternary_operator [left]:expr12 colon [right]:expr12                                    {-> New expr.ternary(condition.expr, left.expr, right.expr)}
  | {factor} [expr]:expr12                                                                                              {-> expr.expr}
;

// Precedence 12 (Logical OR)
expr12 {-> expr} =
	{or} [left]:expr12 or_operator [right]:expr11																		{-> New expr.compare_or(left.expr, right.expr)}
  | {factor} [expr]:expr11																								{-> expr.expr}
;

// Precedence 11 (Logical AND)
expr11 {-> expr} =
	{and} [left]:expr11 and_operator [right]:expr7																		{-> New expr.compare_and(left.expr, right.expr)}
  | {factor} [expr]:expr7																								{-> expr.expr}
;

// Precedence 7 (For relational and respectively)
expr7 {-> expr} =
	{equal} [left]:expr7 equal_operator [right]:expr6																	{-> New expr.compare_equal(left.expr, right.expr)}
  |	{not_equal} [left]:expr7 not_equal_operator [right]:expr6															{-> New expr.compare_not_equal(left.expr, right.expr)}
  | {factor} [expr]:expr6																								{-> expr.expr}
;

// Precedence 6 (For relational operators and respectively)
expr6 {-> expr} =
	{less} [left]:expr6 less_than_operator [right]:expr4																{-> New expr.compare_less(left.expr, right.expr)}
  |	{less_or_equal} [left]:expr6 less_than_or_equal_operator [right]:expr4												{-> New expr.compare_less_or_equal(left.expr, right.expr)}
  |	{greater} [left]:expr6 greater_than_operator [right]:expr4															{-> New expr.compare_greater(left.expr, right.expr)}
  |	{greater_or_equal} [left]:expr6 greater_than_or_equal_operator [right]:expr4										{-> New expr.compare_greater_or_equal(left.expr, right.expr)}
  | {factor} [expr]:expr4																								{-> expr.expr}
;

// Precedence 4 (Addition and subtraction)
expr4 {-> expr} =
	{add} [left]:expr4 add_operator [right]:expr3																		{-> New expr.add(left.expr, right.expr)}
  |	{sub} [left]:expr4 sub_operator [right]:expr3																		{-> New expr.sub(left.expr, right.expr)}
  | {factor} [expr]:expr3																								{-> expr.expr}
;

// Precedence 3 (Multiplication, division, and remainder)
expr3 {-> expr} =
	{multi} [left]:expr3 mult_operator [right]:expr2																	{-> New expr.multi(left.expr, right.expr)}
  |	{div} [left]:expr3 div_operator [right]:expr2																		{-> New expr.div(left.expr, right.expr)}
  |	{mod} [left]:expr3 mod_operator [right]:expr2																		{-> New expr.mod(left.expr, right.expr)}
  | {factor} [expr]:expr2																								{-> expr.expr}
;

// Precedence 2
expr2 {-> expr} =
	// Prefix increment / decrement
	{increment} increment_operator identifier																			{-> New expr.increment(identifier)}
  |	{decrement} decrement_operator identifier																			{-> New expr.decrement(identifier)}
	
	// Unary plus and minus
  |	{unary_plus} add_operator [expr]:expr2																				{-> New expr.unary_plus(expr.expr)}
  |	{unary_minus} sub_operator [expr]:expr2																				{-> New expr.unary_minus(expr.expr)}

	// Negation
  | {negate} negate_operator [expr]:expr2																				{-> New expr.negation(expr.expr)}
  
	// Type cast
  | {cast} l_par [type]:type_specifier r_par [expr]:expr2																{-> New expr.type_cast(type.type_specifier, expr.expr)}
  
  | {factor} [expr]:expr1																								{-> expr.expr}
;

// Precedence 1
expr1 {-> expr} =
  	// Postfix increment / decrement
	{increment} identifier increment_operator																			{-> New expr.increment(identifier)}
  |	{decrement} identifier decrement_operator																			{-> New expr.decrement(identifier)}
  
	// Array
  | {array_subscript} identifier l_bkt [expr]:expr1 r_bkt																{-> New expr.array(identifier, expr.expr)}
  
	// Dot
  | {member} [left]:expr1 dot [right]:expr_value																		{-> New expr.member(left.expr, right.expr)}
  
	// Parenthesis
  | {par} l_par expr r_par																								{-> expr.expr}
  
  | {factor} [expr]:expr_value																							{-> expr.expr}
;

// Function call
function_call {-> expr} =
  	identifier l_par actual_parameter? r_par																			{-> New expr.function_call(identifier, [actual_parameter.expr])}
;
  
// Actual parameters
actual_parameter {-> expr*} =
	{single} expr																										{-> [expr.expr]}
  | {multiple} expr comma actual_parameter																				{-> [expr.expr, actual_parameter.expr]}
;

expr_value {-> expr} =
    {integer}                         integer_literal                                                                   {-> New expr.integer(integer_literal)}
  | {decimal}                         decimal_literal                                                                   {-> New expr.decimal(decimal_literal)}
  | {true}                            true_keyword                                                                      {-> New expr.true()}
  | {false}                           false_keyword                                                                     {-> New expr.false()}
  | {identifier}				      identifier																	    {-> New expr.identifier(identifier)}

  | {port_input_identifier}		      port_input_identifier [expr]:expr_value											{-> New expr.port_input(expr.expr)}
  | {port_output_identifier}	      port_output_identifier [expr]:expr_value											{-> New expr.port_output(expr.expr)}
  | {port_memory_identifier}	      port_memory_identifier [expr]:expr_value											{-> New expr.port_memory(expr.expr)}
  | {port_analog_input_identifier}	  port_analog_input_identifier [expr]:expr_value									{-> New expr.port_analog_input(expr.expr)}
  | {port_analog_output_identifier}   port_analog_output_identifier [expr]:expr_value									{-> New expr.port_analog_output(expr.expr)}
	
  // Precedence changed from C to allow functions in structs
  // Function call
  | {function_call} function_call																						{-> function_call.expr}
;


// Expression

Abstract Syntax Tree

program =
	root_declaration*
;

root_declaration = 
	{declaration} 				declaration 
  |	{function} 					[return_type]:type_specifier	[name]:identifier			[params]:declaration*		[statements]:statement*
  | {struct}					[name]:identifier				[program]:program
  | {enum}                      [name]:identifier				[program]:enum_flag*
;

enum_flag =
    identifier                  [value]:integer_literal?
;
  
declaration =
						        [type]:type_specifier			[name]:identifier           [quailifer]:type_qualifier? [array]:array_definition?
  |	{assignment}				[type]:type_specifier			[name]:identifier           [quailifer]:type_qualifier?	[array]:array_definition?  [expr]:expr
;

array_definition =
                                [number]:integer_literal?
;

type_specifier =
    {char}
  | {bool}
  | {int}
  | {long}
  | {float}
  | {double}
  | {timer}
  | {port}
  | {identifier}                identifier
  | {void}
;

type_qualifier =
    {const}
;

statement =
	{declaration} 				declaration
  | {expr} 						expr
  | {scope}					    statement*
  
  // Conditional
  | {if}						[condition]:expr				[statements]:statement*
  | {if_else}					[condition]:expr				[statements]:statement*		[else]:statement*

  // Switch
  | {switch}                    [condition]:expr                [statements]:statement*
  | {case}                      [case]:expr                     [statements]:statement*
  | {default}                                                   [statements]:statement*

  // Iteration
  | {while}						[condition]:expr				[statements]:statement*
  | {for}						[initilizer]:expr?				[condition]:expr?			[iterator]:expr?
  
  // Control-statements
  | {return}
  | {return_expr}				expr
  | {continue}
  | {break}
;

expr =
  | {identifier}				[name]:identifier

  | {function_call}				[name]:identifier				[args]:expr*
  | {array}						[name]:identifier				expr
  | {member}					[left]:expr						[right]:expr

  | {increment}					[name]:identifier
  | {decrement}					[name]:identifier
  | {unary_plus}				expr
  | {unary_minus}				expr
  | {negation}					expr
  | {type_cast}					[target_type]:type_specifier	expr
  
  | {multi}						[left]:expr						[right]:expr
  | {div}						[left]:expr						[right]:expr
  | {mod}						[left]:expr						[right]:expr

  | {add}						[left]:expr						[right]:expr
  | {sub}						[left]:expr						[right]:expr

  | {compare_less}				[left]:expr						[right]:expr
  | {compare_less_or_equal}		[left]:expr						[right]:expr
  | {compare_greater}			[left]:expr						[right]:expr
  | {compare_greater_or_equal}	[left]:expr						[right]:expr

  | {compare_equal}				[left]:expr						[right]:expr
  | {compare_not_equal}			[left]:expr						[right]:expr
  
  | {compare_and}				[left]:expr						[right]:expr
  | {compare_or}				[left]:expr						[right]:expr
  | {assignment}				[name]:identifier				expr
  | {compound_add}				[name]:identifier				expr
  | {compound_sub}				[name]:identifier				expr
  | {compound_mult}				[name]:identifier				expr
  | {compound_div}				[name]:identifier				expr
  | {compound_mod}				[name]:identifier				expr

  | {ternary}                   [condition]:expr                [left]:expr             [right]:expr

  |	{integer}                   integer_literal
  | {decimal}                   decimal_literal
  | {true}
  | {false}

  | {port_input}                expr
  | {port_output}               expr
  | {port_memory}               expr
  | {port_analog_input}         expr
  | {port_analog_output}        expr
;