Package dk.aau.sw402F15.parser;

Helpers
ht  = 0x0009;
lf  = 0x000a;
ff  = 0x000c;
cr  = 0x000d;
sp  = ' ';

line_terminator = lf | cr | cr lf;

digit =	['0' .. '9'];
letter = ['a' .. 'z'] | ['A' .. 'Z'];
specials = '_';

letter_or_digit = (letter | digit);
letter_or_specials = (letter | specials);
letter_or_digit_or_specials = (letter_or_digit | specials);

Tokens
l_par = '(';
r_par = ')';
l_brc = '{';
r_brc = '}';
semi = ';';
comma = ',';
dot = '.';

// Operators
add_assignment_operator = '+=';
sub_assignment_operator = '-=';
mult_assignment_operator = '*=';
div_assignment_operator = '/=';
mod_assignment_operator = '%=';
assignment_operator = '=';

increment_operator = '++';
decrement_operator = '--';

equal_operator = '==';
not_equal_operator = '!=';
and_operator = '&&';
or_operator = '||';

add_operator = '+';
sub_operator = '-';
mult_operator = '*';
div_operator = '/';
mod_operator = '%';
negate_operator = '!';

greater_than_operator = '>';
less_than_operator = '<';
greater_than_or_equal_operator = '>=';
less_than_or_equal_operator = '<=';

// Keywords
char_keyword = 'char';
bool_keyword = 'bool';
int_keyword = 'int';
long_keyword = 'long';
float_keyword = 'float';
double_keyword = 'double';
port_keyword = 'port';
timer_keyword = 'timer';
void_keyword = 'void';
return_keyword = 'return';
struct_keyword = 'struct';

if_keyword = 'if';
else_keyword = 'else';

for_keyword = 'for';
while_keyword = 'while';

true_keyword = 'true';
false_keyword = 'false';

// Literal
integer_literal = (digit)+;
decimal_literal = (digit)+ '.' (digit)+;

// Identifier
port_identifier = ('I' | 'Q' | 'M' | 'AI' | 'AQ') '#';
identifier = letter_or_specials letter_or_digit_or_specials*;

// White space
white_space = (sp | ht | ff | line_terminator)+;

Ignored Tokens
white_space;

Productions

program =
  {statement} statement program? |
  {function} function_declaration program? |
  {struct} struct program?;

// Types
type = 
  {char} char_keyword | 
  {bool} bool_keyword | 
  {int} int_keyword | 
  {long} long_keyword | 
  {float} float_keyword | 
  {double} double_keyword | 
  {timer} timer_keyword |
  {port} port_keyword |
  {identifier} identifier;
  
// Scope
scope = 
  l_brc statements? r_brc;

// Struct
struct =
  struct_keyword identifier l_brc struct_body? r_brc;

struct_body =
  {declaration} declaration_statement semi struct_body? |
  {function} function_declaration struct_body?;

// Function declaration
functions =
  function_declaration functions?;

function_declaration =
  {function} type identifier l_par formal_parameters? r_par scope |
  {void_function} void_keyword identifier l_par formal_parameters? r_par scope;

// Function call
function_call =
  identifier l_par actual_parameters? r_par;
  
// Parameters
formal_parameters =
  formal_parameter additional_formal_parameter?;
  
actual_parameters = 
  actual_parameter additional_actual_parameter?;
  
formal_parameter = 
  type identifier;
  
additional_formal_parameter = 
  comma formal_parameters;
  
actual_parameter =
  expr;
  
additional_actual_parameter =
  comma actual_parameters;
  
// Statements
statements = 
  statement statements?;

statement = 
  {declaration} declaration_statement semi |
  {assignment} assignment_statement semi |
  {conditional} conditional_statement |
  {iterative} iterative_statement |
  {scope} scope |
  {unary_assignment} unary_assignment semi |
  {semi} semi |
  {function} function_call additional_identifier? semi |
  {return} return_statement semi;

// Return statement
return_statement =
  {normal_return} return_keyword expr |
  {void_return} return_keyword;

// Declaration
declaration_statement =
  {declaration} type identifier |
  {declaration_assignment} type identifier assignment_operator expr;

// Assignment
assignment_statement = 
  {assignment} identifier additional_identifier? assignment_operator expr;
  
unary_assignment =
  {add} identifier add_assignment_operator expr |
  {sub} identifier sub_assignment_operator expr |
  {mult} identifier mult_assignment_operator expr |
  {div} identifier div_assignment_operator expr |
  {mod} identifier mod_assignment_operator expr |
  {unary} unary_expression;
  
// Conditional statement
conditional_statement =
  {if} if_statement;

if_statement =
  {if} if_keyword l_par expr r_par scope |
  {if_else} if_keyword l_par expr r_par scope else_statement;

else_statement = 
  {else} else_keyword scope |
  {else_if} else_keyword if_statement;

// Iterative statement
iterative_statement =
  {while} while_statement |
  {for} for_statement;
  
while_statement = 
  {while} while_keyword l_par expr r_par scope;

for_statement =
  {for} for_keyword l_par for_initializer for_condition for_iterator r_par scope;
  
for_initializer =
  {assignment} assignment_statement semi |
  {declaration} declaration_statement semi;

for_condition =
  {expr} expr semi;
  
for_iterator =
  {iterator} assignment_statement |
  {unary_assign} unary_assignment;

// Additional identifier
additional_identifier =
  {identifier} dot identifier additional_identifier? |
  {function} dot function_call additional_identifier?;

// Expression
expr = 
  {compare_and} expr and_operator expr2 |
  {compare_or} expr or_operator expr2 |
  {term} expr2;

expr2 =
  {compare_equal} expr2 equal_operator expr3 | 
  {compare_not_equal} expr2 not_equal_operator expr3 | 
  {term} expr3;

expr3 =
  {compare_greater} expr3 greater_than_operator expr4 |
  {compare_less} expr3 less_than_operator expr4 |
  {compare_greater_or_equal} expr3 greater_than_or_equal_operator expr4 |
  {compare_less_or_equal} expr3 less_than_or_equal_operator expr4 |
  {term} expr4;

expr4 =
  {add} expr4 add_operator expr5 |
  {sub} expr4 sub_operator expr5 |
  {term} expr5;

expr5 =
  {multi} expr5 mult_operator expr_value |
  {div} expr5 div_operator expr_value |
  {mod} expr5 mod_operator expr_value |
  {negated} negate_operator expr_value |
  {term} expr_value;

expr_value =
  {value} value |
  {expr} l_par expr r_par;

value =
  {unary} unary_expression |
  {integer} integer_literal |
  {decimal} decimal_literal |
  {true} true_keyword | 
  {false} false_keyword |
  {function} function_call additional_identifier? |
  {identifier} identifier additional_identifier? |
  {negative} sub_operator value |
  {port} port_identifier expr;
  
unary_expression = 
  {increment_prefix} increment_operator identifier |
  {increment_suffix} identifier increment_operator |
  {decrement_prefix} decrement_operator identifier |
  {decrement_suffix} identifier decrement_operator;