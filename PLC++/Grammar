Package dk.aau.sw402F15.parser;

Helpers
ht  = 0x0009;
lf  = 0x000a;
ff  = 0x000c;
cr  = 0x000d;
sp  = ' ';

line_terminator = lf | cr | cr lf;

digit =	['0' .. '9'];
letter = ['a' .. 'z'] | ['A' .. 'Z'];
specials = '_';

letter_or_digit = (letter | digit);
letter_or_specials = (letter | specials);
letter_or_digit_or_specials = (letter_or_digit | specials);

Tokens
l_par = '(';
r_par = ')';
l_brc = '{';
r_brc = '}';
semi = ';';
comma = ',';
dot = '.';

// Operators
add_assignment_operator = '+=';
sub_assignment_operator = '-=';
mult_assignment_operator = '*=';
div_assignment_operator = '/=';
mod_assignment_operator = '%=';
assignment_operator = '=';

increment_operator = '++';
decrement_operator = '--';

equal_operator = '==';
not_equal_operator = '!=';
and_operator = '&&';
or_operator = '||';

add_operator = '+';
sub_operator = '-';
mult_operator = '*';
div_operator = '/';
mod_operator = '%';
negate_operator = '!';

greater_than_operator = '>';
less_than_operator = '<';
greater_than_or_equal_operator = '>=';
less_than_or_equal_operator = '<=';

// Keywords
char_keyword = 'char';
bool_keyword = 'bool';
int_keyword = 'int';
long_keyword = 'long';
float_keyword = 'float';
double_keyword = 'double';
port_keyword = 'port';
timer_keyword = 'timer';
void_keyword = 'void';
return_keyword = 'return';
struct_keyword = 'struct';

if_keyword = 'if';
else_keyword = 'else';

for_keyword = 'for';
while_keyword = 'while';

true_keyword = 'true';
false_keyword = 'false';

// Literal
integer_literal = (digit)+;
decimal_literal = (digit)+ '.' (digit)+;

// Identifier
port_identifier = ('I' | 'Q' | 'M' | 'AI' | 'AQ') '#';
identifier = letter_or_specials letter_or_digit_or_specials*;

// White space
white_space = (sp | ht | ff | line_terminator)+;

Ignored Tokens
white_space;

Productions

program =
    {statement} statement program?
  | {function} function_declaration program?
  | {struct} struct program?;

// Types
type = 
    {char} char_keyword
  | {bool} bool_keyword
  | {int} int_keyword
  | {long} long_keyword
  | {float} float_keyword
  | {double} double_keyword
  | {timer} timer_keyword
  | {port} port_keyword
  | {identifier} identifier;
  
// Scope
scope = 
    l_brc statements? r_brc;

// Struct
struct =
    struct_keyword identifier l_brc struct_body? r_brc;

struct_body =
    {declaration} declaration_statement semi struct_body?
  | {function} function_declaration struct_body?;

// Function declaration
functions =
    function_declaration functions?;

function_declaration =
    {function} type identifier l_par formal_parameters? r_par scope
  | {void_function} void_keyword identifier l_par formal_parameters? r_par scope;

// Function call
function_call =
    identifier l_par actual_parameters? r_par;
  
// Parameters
formal_parameters =
    formal_parameter additional_formal_parameter?;
  
actual_parameters = 
    actual_parameter additional_actual_parameter?;
  
formal_parameter = 
    type identifier;
  
additional_formal_parameter = 
    comma formal_parameters;
  
actual_parameter =
    expr;
  
additional_actual_parameter =
    comma actual_parameters;
  
// Statements
statements = 
    statement statements?;

statement = 
    {declaration} declaration_statement semi
  | {assignment} assignment_statement semi
  | {conditional} conditional_statement
  | {iterative} iterative_statement
  | {scope} scope
  | {unary_assignment} unary_assignment semi
  | {semi} semi
  | {function} function_call additional_identifier? semi
  | {return} return_statement semi;

// Return statement
return_statement =
    {normal_return} return_keyword expr
  | {void_return} return_keyword;

// Declaration
declaration_statement =
    {declaration} type identifier
  | {declaration_assignment} type identifier assignment_operator expr;

// Assignment
assignment_statement = 
    {assignment} identifier additional_identifier? assignment_operator expr;
  
unary_assignment =
    {add} identifier add_assignment_operator expr
  | {sub} identifier sub_assignment_operator expr
  | {mult} identifier mult_assignment_operator expr
  | {div} identifier div_assignment_operator expr
  | {mod} identifier mod_assignment_operator expr
  | {unary} unary_expression;
  
// Conditional statement
conditional_statement =
    {if} if_statement;

if_statement =
    {if} if_keyword l_par expr r_par scope
  | {if_else} if_keyword l_par expr r_par scope else_statement;

else_statement = 
    {else} else_keyword scope
  | {else_if} else_keyword if_statement;

// Iterative statement
iterative_statement =
    {while} while_statement
  | {for} for_statement;
  
while_statement = 
    {while} while_keyword l_par expr r_par scope;

for_statement =
    {for} for_keyword l_par for_initializer for_condition for_iterator r_par scope;
  
for_initializer =
    {assignment} assignment_statement semi
  | {declaration} declaration_statement semi;

for_condition =
    {expr} expr semi;
  
for_iterator =
    {iterator} assignment_statement
  | {unary_assign} unary_assignment;

// Additional identifier
additional_identifier =
    {identifier} dot identifier additional_identifier?
  | {function} dot function_call additional_identifier?;

// Expression
expr {-> expr} =
    {compare_and}               [left]:expr       and_operator                   [right]:expr2                          {-> New expr.compare_and(left.expr, right.expr)}
  | {compare_or}                [left]:expr       or_operator                    [right]:expr2                          {-> New expr.compare_or(left.expr, right.expr)}
  | {term}                      expr2                                                                                   {-> expr2.expr}
;

expr2 {-> expr} =
    {compare_equal}             [left]:expr2      equal_operator                 [right]:expr3                          {-> New expr.compare_equal(left.expr, right.expr)}
  | {compare_not_equal}         [left]:expr2      not_equal_operator             [right]:expr3                          {-> New expr.compare_not_equal(left.expr, right.expr)}
  | {term}                      expr3                                                                                   {-> expr3.expr}
;

expr3 {-> expr} =
    {compare_greater}           [left]:expr3      greater_than_operator          [right]:expr4                          {-> New expr.compare_greater(left.expr, right.expr)}
  | {compare_less}              [left]:expr3      less_than_operator             [right]:expr4                          {-> New expr.compare_less(left.expr, right.expr)}
  | {compare_greater_or_equal}  [left]:expr3      greater_than_or_equal_operator [right]:expr4                          {-> New expr.compare_greater_or_equal(left.expr, right.expr)}
  | {compare_less_or_equal}     [left]:expr3      less_than_or_equal_operator    [right]:expr4                          {-> New expr.compare_less_or_equal(left.expr, right.expr)}
  | {term}                      expr4                                                                                   {-> expr4.expr}
;

expr4 {-> expr} =
    {add}                       [left]:expr4      add_operator                   [right]:expr5                          {-> New expr.add(left.expr, right.expr)}
  | {sub}                       [left]:expr4      sub_operator                   [right]:expr5                          {-> New expr.sub(left.expr, right.expr)}
  | {term}                      expr5                                                                                   {-> expr5.expr}
;

expr5 {-> expr} =
    {multi}                     [left]:expr5      mult_operator                  [right]:expr_value                     {-> New expr.multi(left.expr, right.expr)}
  | {div}                       [left]:expr5      div_operator                   [right]:expr_value                     {-> New expr.div(left.expr, right.expr)}
  | {mod}                       [left]:expr5      mod_operator                   [right]:expr_value                     {-> New expr.mod(left.expr, right.expr)}
  | {negated}                   negate_operator                                  [right]:expr_value                     {-> New expr.negate_bool(right.expr)}
  | {term}                      expr_value                                                                              {-> expr_value.expr}
;

expr_value {-> expr} =
    {value}                     value                                                                                   {-> value.expr}
  | {expr}                      l_par expr r_par                                                                        {-> expr}
;

value {-> expr} =
//    {unary}                     unary_expression                                                                        {-> New expr.unary_expression(unary)}
  {integer}                   integer_literal                                                                         {-> New expr.integer(integer_literal)}
  | {decimal}                   decimal_literal                                                                         {-> New expr.decimal(decimal_literal)}
  | {true}                      true_keyword                                                                            {-> New expr.true()}
  | {false}                     false_keyword                                                                           {-> New expr.false()}
//  | {function}                  [name]:function_call additional_identifier?                                             {-> New expr.function(name)}
//  | {identifier}                [name]:identifier additional_identifier?                                                {-> New expr.identifier(name)}
  | {negative}                  sub_operator [right]:value                                                              {-> New expr.negate_number(right.expr)}
//  | {port}                      port_identifier expr
;
  
unary_expression =//{-> expr} =
    {increment_prefix}          [name]:increment_operator identifier
  | {increment_suffix}          [name]:identifier increment_operator
  | {decrement_prefix}          [name]:decrement_operator identifier
  | {decrement_suffix}          [name]:identifier decrement_operator
;

Abstract Syntax Tree

unit_of_work =
    program*
;

program =
    statement
  | struct
;



function =
    {call}                      [name]:identifier         [args]:expr*
;

expr =
    {compare_and}               [left]:expr               [right]:expr
  | {compare_or}                [left]:expr               [right]:expr
  | {compare_equal}             [left]:expr               [right]:expr
  | {compare_not_equal}         [left]:expr               [right]:expr
  | {compare_greater}           [left]:expr               [right]:expr
  | {compare_less}              [left]:expr               [right]:expr
  | {compare_greater_or_equal}  [left]:expr               [right]:expr
  | {compare_less_or_equal}     [left]:expr               [right]:expr
  | {add}                       [left]:expr               [right]:expr
  | {sub}                       [left]:expr               [right]:expr
  | {multi}                     [left]:expr               [right]:expr
  | {div}                       [left]:expr               [right]:expr
  | {mod}                       [left]:expr               [right]:expr
  | {negate_bool}                                         [right]:expr
  | {negate_number}                                       [right]:expr
  | {integer}                                             [right]:integer_literal
  | {decimal}                                             [right]:decimal_literal
  | {true}
  | {false}
//  | {function}                  [left]:function           [right]:additional_identifier?
;