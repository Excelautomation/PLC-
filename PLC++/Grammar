Package dk.aau.sw402F15.parser;

Helpers
ht  = 0x0009;
lf  = 0x000a;
ff  = 0x000c;
cr  = 0x000d;
sp  = ' ';

line_terminator = lf | cr | cr lf;

digit =	['0' .. '9'];
letter = ['a' .. 'z'] | ['A' .. 'Z'];

letter_or_digit = (letter | digit);

Tokens
white_space = (sp | ht | ff | line_terminator)+;

integer = (digit)+;
decimal = (digit)+ '.' (digit)+;

identifier = letter;// letter_or_digit*;

l_par = '(';
r_par = ')';
l_brc = '{';
r_brc = '}';

byte = 'byte';
bool = 'bool';
int = 'int';
long = 'long';
float = 'float';
double = 'double';
port = 'port';

assignment_operator = '=';

plus_operator = '+';
minus_operator = '-';
mult_operator = '*';
div_operator = '/';
mod_operator = '%';

equal_operator = '==';
not_equal_operator = '!=';
and_operator = '&&';
or_operator = '||';

greater_than_operator = '>';
less_than_operator = '<';
greater_than_or_equal_operator = '>=';
less_than_or_equal_operator = '<=';

// Keywords
if_keyword = 'if';
else_keyword = 'else';

for_keyword = 'for';

true_keyword = 'true';
false_keyword = 'false';

semi = ';';

Ignored Tokens
white_space;

Productions

program = 
  statements;

statements = 
  {multi} statement statements |
  {single} statement;

statement = 
  {declaration} declaration_statement semi |
  {assignment} assignment_statement semi;

type = 
  {byte} byte | 
  {bool} bool | 
  {int} int | 
  {long} long | 
  {float} float | 
  {double} double | 
  {port} port;
  
variable_identifier = 
  {identifier} identifier;

declaration_statement =
  {declaration} type variable_identifier |
  {declaration_assignment} type assignment_statement;
  
assignment_statement = 
  {assignment} variable_identifier assignment_operator expr;

expr = 
  {logic_expr} logic_expr |
  {value_expr} value_expr |
  {identifier} variable_identifier;

logic_expr = 
  {compare_and} logic_expr and_operator logic_term |
  {compare_or} logic_expr or_operator logic_term |
  {term} logic_term;

logic_term = 
  {compare_equal} logic_value equal_operator logic_term | 
  {compare_not_equal} logic_value not_equal_operator logic_term | 
  {value} logic_value;

logic_value = 
  {true} true_keyword | 
  {false} false_keyword | 
//  {identifier} variable_identifier | Ambigius
  {expr} l_par logic_expr r_par |
  {compare} logic_compare;
  
logic_compare = 
  {compare_greater} logic_value_term greater_than_operator value_term |
  {compare_less} logic_value_term less_than_operator value_term |
  {compare_greater_or_equal} logic_value_term greater_than_or_equal_operator value_term |
  {compare_less_or_equal} logic_value_term less_than_or_equal_operator value_term;
  
logic_value_term = {logic_value_term} value_term;
  
value_expr =
  {add} value_expr plus_operator value_factor |
  {sub} value_expr minus_operator value_factor |
  {factor} value_factor;
  
value_factor =
  {multi} value_factor mult_operator value_term |
  {div} value_factor div_operator value_term |
  {mod} value_factor mod_operator value_term |
  {term} value_term;

value_term =
  {expr} l_par value_expr r_par |
  {value} value; //| Ambigius
//  {identifier} variable_identifier;
  
value =
  {number} number |
  {negnumber} minus_operator number;
  
number =
  {integer} integer |
  {decimal} decimal;